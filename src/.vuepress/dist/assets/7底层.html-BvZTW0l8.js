import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,b as n,o as i}from"./app-eWV4nnR8.js";const r="/assets/image-20241222134425730-BFMwSIKO.png",l={};function a(s,e){return i(),o("div",null,e[0]||(e[0]=[n('<h2 id="_1-基础" tabindex="-1"><a class="header-anchor" href="#_1-基础"><span>1. 基础</span></a></h2><ul><li><code>@Scope(value = &quot;prototype&quot;)</code>：默认单例，加上后创建的是多例的对象</li><li><code>@PostConstruct</code>：通过注解指定在构造器完成后执行的方法，即完成初始化任务</li><li><code>@EnableAspectJAutoProxy</code>：AOP 实现 Spring 可以通过给加了这个注解的类</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><ol><li>AOP 底层是基于 BeanPostProcessor 机制的</li><li>即在 Bean 创建好后，根据是否需要 AOP 处理，决定返回代理对象，还是原生Bean</li><li>在返回代理对象时，就可以根据要代理的类和方法来返回</li><li>其实这个机制并不难，本质就是在 BeanPostProcessor 机制+ 动态代理技术</li><li></li></ol></div><h2 id="_2-spring-底层实现-aop" tabindex="-1"><a class="header-anchor" href="#_2-spring-底层实现-aop"><span>2. Spring 底层实现 AOP</span></a></h2><h3 id="_2-1-整体架构分析" tabindex="-1"><a class="header-anchor" href="#_2-1-整体架构分析"><span>2.1 整体架构分析</span></a></h3><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',6)]))}const d=t(l,[["render",a],["__file","7底层.html.vue"]]),h=JSON.parse('{"path":"/codenotes/back/spring/spring/7%E5%BA%95%E5%B1%82.html","title":"","lang":"zh-CN","frontmatter":{"description":"1. 基础 @Scope(value = \\"prototype\\")：默认单例，加上后创建的是多例的对象 @PostConstruct：通过注解指定在构造器完成后执行的方法，即完成初始化任务 @EnableAspectJAutoProxy：AOP 实现 Spring 可以通过给加了这个注解的类 提示 AOP 底层是基于 BeanPostProcessor...","head":[["meta",{"property":"og:url","content":"https://hwchen.top/codenotes/back/spring/spring/7%E5%BA%95%E5%B1%82.html"}],["meta",{"property":"og:site_name","content":"Ahzy"}],["meta",{"property":"og:description","content":"1. 基础 @Scope(value = \\"prototype\\")：默认单例，加上后创建的是多例的对象 @PostConstruct：通过注解指定在构造器完成后执行的方法，即完成初始化任务 @EnableAspectJAutoProxy：AOP 实现 Spring 可以通过给加了这个注解的类 提示 AOP 底层是基于 BeanPostProcessor..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ahzy\\",\\"url\\":\\"https://gitee.com/private_crh\\"}]}"]]},"headers":[{"level":2,"title":"1. 基础","slug":"_1-基础","link":"#_1-基础","children":[]},{"level":2,"title":"2. Spring 底层实现 AOP","slug":"_2-spring-底层实现-aop","link":"#_2-spring-底层实现-aop","children":[{"level":3,"title":"2.1 整体架构分析","slug":"_2-1-整体架构分析","link":"#_2-1-整体架构分析","children":[]}]}],"git":{},"readingTime":{"minutes":0.58,"words":175},"filePathRelative":"codenotes/back/spring/spring/7底层.md","excerpt":"<h2>1. 基础</h2>\\n<ul>\\n<li><code>@Scope(value = \\"prototype\\")</code>：默认单例，加上后创建的是多例的对象</li>\\n<li><code>@PostConstruct</code>：通过注解指定在构造器完成后执行的方法，即完成初始化任务</li>\\n<li><code>@EnableAspectJAutoProxy</code>：AOP 实现 Spring 可以通过给加了这个注解的类</li>\\n</ul>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">提示</p>\\n<ol>\\n<li>AOP 底层是基于 BeanPostProcessor 机制的</li>\\n<li>即在 Bean 创建好后，根据是否需要 AOP 处理，决定返回代理对象，还是原生Bean</li>\\n<li>在返回代理对象时，就可以根据要代理的类和方法来返回</li>\\n<li>其实这个机制并不难，本质就是在 BeanPostProcessor 机制+ 动态代理技术</li>\\n<li></li>\\n</ol>\\n</div>","autoDesc":true}');export{d as comp,h as data};
